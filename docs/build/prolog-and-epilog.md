---
title: x64 프롤로그 및 에필로그
ms.date: 12/17/2018
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
ms.openlocfilehash: a225786853fcc2eb7b6a21de29f1ccf4901e4377
ms.sourcegitcommit: 8105b7003b89b73b4359644ff4281e1595352dda
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/14/2019
ms.locfileid: "57809989"
---
# <a name="x64-prolog-and-epilog"></a>x64 프롤로그 및 에필로그

스택 공간을 할당 하는 모든 함수를 호출 함수, 비휘발성 레지스터를 저장 또는 예외 처리를 사용 하 여 다른 주소 제한 된 각 함수의 테이블 항목과 연결 된 해제 데이터에서 설명 하는 프롤로그가 있어야 합니다. 자세한 내용은 [x64 예외 처리](../build/exception-handling-x64.md)합니다. 프롤로그 저장 인수 레지스터 홈 주소에 필요한 경우 비휘발성 레지스터를 스택에 푸시합니다, 지역 및 임시 개체를 고정된 부분의 스택 할당 및 필요에 따라 프레임 포인터를 설정 합니다. 연결 된 해제 데이터 프롤로그의 동작을 설명 하 고 prolog 코드의 효과 취소 하는 데 필요한 정보를 제공 해야 합니다.

스택에서 고정된 할당에 둘 이상의 페이지인 경우 (즉, 4096 바이트 보다 큰)에 스택 할당 둘 이상의 가상 메모리 페이지가 표시 될 수 있으며, 따라서 할당 하기 전에 할당을 확인 해야 합니다. 특별 한 루틴 프롤로그에서 호출할 수 있고 인수 레지스터 중 하나를 제거 하지 않습니다는이 목적을 위해 제공 됩니다.

비휘발성 레지스터를 저장 하기 위한 기본 메서드를 고정된 스택 할당 하기 전에 스택으로 이동 하는 것입니다. 비휘발성 레지스터 저장 되기 전에 고정된 스택 할당 수행 가능성이 가장 큰 32 비트 치환 경우 저장 된 레지스터 영역을 해결 하는 데 필요한 합니다. (나타내기 레지스터가 빨리 이동 하 고 있으므로 푸시 간에 암시적된 종속성도 불구 하 고 예측 가능한 미래에 대 한 상태로 유지 해야 합니다.) 비휘발성 레지스터 순서에 관계 없이 저장할 수 있습니다. 그러나 프롤로그에서 비휘발성 레지스터의 첫 번째 사용 저장 해야 합니다.

## <a name="prolog-code"></a>프롤로그 코드

일반적인 프롤로그 코드는 다음과 같습니다.

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    sub    RSP, fixed-allocation-size
    lea    R13, 128[RSP]
    ...
```

이 프롤로그 홈 위치에서 인수 RCX 레지스터를 저장, 저장 비휘발성 등록 R13-r 15 고정된 부분의 스택 프레임을 할당 하 고 고정된 할당 영역에 128 바이트를 가리키는 프레임 포인터를 설정 합니다. 오프셋을 사용 하면 고정된 할당 영역 1 바이트 오프셋을 사용 하 여 해결을 더 합니다.

고정된 할당 크기 보다 크거나 같은 메모리의 한 페이지로 이면 RSP 수정 하기 전에 도우미 함수를 호출 되어야 합니다. 이 도우미 `__chkstk`, 스택의 제대로 확장 되도록 스택 할당 하려는 범위를 검색 합니다. 이 경우 앞의 프롤로그 예제 대신 다음과 같습니다.

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    mov    RAX,  fixed-allocation-size
    call   __chkstk
    sub    RSP, RAX
    lea    R13, 128[RSP]
    ...
```

`__chkstk` 도우미 R10, R11 및 조건 코드 레지스터를 수정 하지 것입니다. 특히 RAX 변경 되지 않은 상태로 반환 하 고 모든 비휘발성 레지스터와 수정 되지 않은 인수 전달 레지스터를 유지 합니다.

## <a name="epilog-code"></a>에필로그 코드

에필로그 코드는 모든 함수 종료 위치에 있습니다. 일반적으로 하나만 프롤로그 인 반면 많은 에필로그 있을 수 있습니다. 에필로그 코드 필요에 따라 고정된 할당 크기로 스택 트림, 고정된 스택 할당의 할당을 취소, 비휘발성 레지스터 스택에서 해당 저장된 값을 팝 하 여 복원 및 반환 합니다.

에필로그 코드에서 예외 및 인터럽트를 통해 안정적으로 해제 하려면 엄격한 해제 코드에 대 한 규칙 집합을 따라야 합니다. 이러한 규칙의 양을 줄일 추가 데이터가 없습니다. 각 에필로그를 설명 하기 위해 필요 하므로 필요한 데이터를 해제 합니다. 대신 해제 코드는 에필로그 에필로그를 식별 하는 코드 스트림을 통해 앞으로 검색 하 여 실행 될 것임을 확인할 수 있습니다.

프레임 포인터가 사용 되는 경우 함수를 다음 에필로그 먼저 할당을 취소 해야 고정된 부분의 스택의 비휘발성 레지스터를 팝 및 컨트롤이 호출 함수로 반환 됩니다. 예를 들면 다음과 같습니다.

```MASM
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

프레임 포인터를 함수에서 사용 하는 경우 스택 에필로그의을 실행 하기 전에 고정된 할당으로 트리밍 해야 합니다. 이 동작은 기술적의 일부가 아닌 에필로그에 설명 합니다. 예를 들어, 이전에 사용 하는 프롤로그를 실행 취소 하려면 다음 에필로그를 사용할 수 있습니다.

```MASM
    lea      RSP, -128[R13]
    ; epilogue proper starts here
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

실제로 프레임 포인터를 사용 하면 없습니다 좋은 이유는 다음 에필로그를 대신 사용할 수는 두 단계로 RSP를 조정 하려면:

```MASM
    lea      RSP, fixed-allocation-size - 128[R13]
    pop      R13
    pop      R14
    pop      R15
    ret
```

이러한 양식은 에필로그에만 유효한 것으로 구성 되어 있습니다. 구성 되어야 합니다는 `add RSP,constant` 또는 `lea RSP,constant[FPReg]`뒤에 0 개 이상의 8 바이트 등록 pop의 시리즈, 및 `return` 또는 `jmp`합니다. (의 하위 집합만 `jmp` 문은 에필로그에 허용 되는 합니다. 하위 집합은 단독으로 클래스 `jmp` 가장 ModRM mod 필드 값이 00 ModRM 메모리 참조를 사용 하 여 문입니다. 사용 `jmp` ModRM 01 또는 10 mod 필드 값은 금지를 사용 하 여 에필로그에 문의 합니다. 테이블 A-15 AMD 64 x86 아키텍처 프로그래머의 수동 볼륨 3 참조 하세요. 범용 및 시스템 지침에 허용 가능한 ModRM 참조에 대 한 자세한 정보.) 다른 코드가 없어야 나타날 수 있습니다. 특히, 아무 것도 반환 값을 로드 하는 등 에필로그 내에서 예약할 수 있습니다.

프레임 포인터를 사용 하지 않으면 하는 경우 에필로그를 사용 해야 `add RSP,constant` 고정된 부분의 스택 할당을 취소 합니다. 사용할 수 없습니다 `lea RSP,constant[RSP]` 대신 합니다. 이 제한이 없으므로 해제 코드는 에필로그를 검색할 때 인식 하는 더 적은 패턴에 있습니다.

다음 규칙 해제 코드를 에필로그는 현재 실행 되 고 있음을 확인 하 고 실행 호출 함수의 컨텍스트를 다시 만들 수 있도록 에필로그의 나머지 부분을 시뮬레이션할 수 있습니다.

## <a name="see-also"></a>참고자료

[x64 소프트웨어 규칙](x64-software-conventions.md)
